# Alice and Bob want to exchange messages over an insecure channel.
# They decide to use a symmetric cipher and a MAC to ensure their confidentiality and authenticity.
# To make their communication more secure, they opt to use random 32 bytes ephemeral keys
# generated using a hash-based PRNG, for which they previously agreed on the initial state.
#
# Mallory is an attacker who has access to the communication channel between Alice and Bob,
# but does not know the initial state of their hash RNG. However, she knows the exact security
# stack they are using (ChaCha20 + HMAC), as well as the key sizes, and also that
# the RNG is used to compute the HMAC key first, and then the encryption key.
#
# Your task is to:
# 1. Implement the hash RNG, based on computing the SHA-256 hash of an increasing counter value.
#    Numbers generated by this RNG should be 64-bit integers.
# 2. Allow Mallory to tamper with the communication by correctly guessing the initial state
#    of the RNG and exploiting this information to send a forged message to Bob.
#
# Hints:
# - You can use the MAC provided in the message to verify if a guessed seed is correct.
# - Keys are generated using the `bytes` method of the `RNG` base class. This method works
#   by repeatedly calling `__next__` and concatenating the results until the requested length
#   is reached. You should take this into account when trying to generate the enctyption key
#   after finding the seed used to generate the HMAC key.


from issp import HMAC, RNG, Actor, ChaCha20, Channel, Message, log

KEY_SIZE = 32


class SHA256RNG(RNG[int]):
    VALUE_SIZE = 8

    def __init__(self) -> None:
        self._counter = 12345

    def __next__(self) -> int:
        # TO-DO: Compute the output and update the internal state.
        return self._counter

    def set_seed(self, seed: int) -> None:
        # TO-DO: Set the internal state to the given seed value.
        pass


def alice(channel: Channel, rng: SHA256RNG) -> None:
    channel = channel.with_stack(ChaCha20(rng.bytes(KEY_SIZE)) | HMAC(key=rng.bytes(KEY_SIZE)))
    channel.send(Message("Alice", "Bob", "Hello, Bob!"))


def bob(channel: Channel, rng: SHA256RNG) -> None:
    channel = channel.with_stack(ChaCha20(rng.bytes(KEY_SIZE)) | HMAC(key=rng.bytes(KEY_SIZE)))
    channel.receive("Bob")


def mallory(channel: Channel) -> None:
    msg = channel.receive()

    enc_key = bytes(KEY_SIZE)
    mac_key = bytes(KEY_SIZE)

    # TO-DO: Find the correct seed through brute-force, and use it to generate
    #        the same keys as Alice and Bob.

    channel = channel.with_stack(ChaCha20(enc_key) | HMAC(key=mac_key))
    msg.body = "Screw you, Bob!"
    channel.send(msg)


def main() -> None:
    alice_rng = SHA256RNG()

    for i in range(10):
        log.info("[SHA256 RNG] Value %d: %d", i + 1, next(alice_rng))

    seed = 12345
    bob_rng = SHA256RNG()
    alice_rng.set_seed(seed)
    bob_rng.set_seed(seed)

    Actor.start(
        Actor(alice, data=(alice_rng,)),
        Actor(bob, data=(bob_rng,)),
        Actor(mallory, priority=1),
    )


if __name__ == "__main__":
    main()
